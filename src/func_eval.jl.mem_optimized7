        - 
        - ## forward evaluation 
        - function evaluate(tt::TT_TYPE,idx::IDX_TYPE, vvals::TV_TYPE, pvals::TV_TYPE)
        - 	# debug("enter - ",idx)
        - 	# assert(idx != 0)	
        - 	ret::VV_TYPE = 0.0
        - 	ntype = tt[idx] #type node
        - 	idx -= 1
        - 	if(ntype == TYPE_P)
        - 		ret = pvals[tt[idx]]
        - 		idx -=1
        - 	elseif(ntype == TYPE_V)
        - 		ret = vvals[tt[idx]]
        - 		idx -= 1
        - 	# elseif(ntype == TYPE_OU)
        - 	# 	oc = tt[idx]
        - 	# 	assert(U_OP_START <= oc <= U_OP_END)
        - 	# 	idx -= 1
        - 	# 	lidx = tt[idx]
        - 	# 	idx -= 1
        - 	# 	# debug("unary before  - ",lidx)
        - 	# 	(lval,idx) = evaluate(tt,lidx,vvals,pvals)
        - 	# 	ret = evaluate(OP[oc],lval)
        - 	# elseif(ntype == TYPE_OB)
        - 	# 	oc = tt[idx]
        - 	# 	assert(B_OP_START<= oc <= B_OP_END)
        - 	# 	idx -= 1
        - 	# 	ridx = tt[idx]
        - 	# 	idx -= 1
        - 	# 	lidx = tt[idx]
        - 	# 	idx -= 1
        - 	# 	# debug("before right - ",ridx)
        - 	# 	(rval,idx) = evaluate(tt,ridx,vvals,pvals)
        - 	# 	# debug("before left - ",lidx)
        - 	# 	(lval,idx) = evaluate(tt,lidx,vvals,pvals)
        - 	# 	ret = evaluate(OP[oc],lval,rval)
        - 	else
        - 		num = ntype - 2
        - 		oc = tt[idx]
        - 		idx -= 1
        - 		# assert(oc==1 || oc ==3) #:+ or :* symbol
        - 		ovals = Array{VV_TYPE,1}()
        - 		nidx = 0
        - 		for i = 1:1:num
        - 			oidx = tt[idx]
        - 			idx -= 1
        - 			(rval,nidx) = evaluate(tt,oidx,vvals,pvals)
        - 			push!(ovals,rval)
        - 		end
        - 		idx = nidx
        - 		# @show OP[oc]
        - 		ret = evaluate(OP[oc],ovals...)
        - 		# assert(false)
        - 	end
        - 
        - 	# assert(!isnan(ret))
        - 	# debug("exit - ",idx)
        - 	return ret,idx
        - end
        - 
        - 
        - # function evaluate(s::Symbol, nvals::Array{VV_TYPE,1}, i)
        - # 	# n = length(nvals)
        - # 	if(s == :+)
        0 # 		result = 0.0
        0 # 		@simd for j=i:1:length(nvals)
        0 # 			@inbounds result+=nvals[j]
        0 # 		end
        - # 		return result
        0 # 		# return Base.sum(nvals[i:1:end])
        0 # 	elseif(s == :-)
        0 # 		@inbounds return (-)(nvals[i],nvals[i+1])
        0 # 	elseif(s == :*)
        0 # 		result = nvals[i]
        0 # 		@simd for j=i+1:1:length(nvals)
        - # 			@inbounds result *= nvals[j]
        - # 		end
        - # 		@inbounds return result
        0 # 		# return Base.prod(nvals[i:1:end])
        - # 	elseif(s == :/)
        - # 		@inbounds return (/)(nvals[i],nvals[i+1])
        - # 	elseif(s == :^)
        - # 		@inbounds return (^)(nvals[i],nvals[i+1])
        0 # 	elseif(s == :sin)
        - # 		@inbounds return sin(nvals[i])
        - # 	elseif(s == :cos)
        - # 		@inbounds return cos(nvals[i])
        - # 	end
        - # end
        - 
        - # function sum_n(x::Array{VV_TYPE,1},n)
        - # 	result = 0.0
        - # 	for i in 1:1:n
        - # 		result += x[i]
        - # 	end
        - # 	return result
        - # end
        - 
        - 
        - # function prod_n(x::Array{VV_TYPE,1},n)
        - # 	result = 0.0
        - # 	for i in 1:1:n
        - # 		result *= x[i]
        - # 	end
        - # 	return result
        - # end
        - 
        - # @eval 	function evaluate(oc, args...)
        - # 			s = OP[oc]
        - # 			out = Expr(:if)
        - # 			comp = Expr(:comparison)
        - 
        - # 			if(s == :+)
        - # 				return (+)(args...)
        - # 			elseif(s == :-)
        - # 				return (-)(args...)
        - # 			elseif(s == :*)
        - # 				return (*)(args...)
        - # 			elseif(s == :/)
        - # 				return (/)(args...)
        - # 			elseif(s == :^)
        - # 				return (^)(args...)
        - # 			elseif(s == :sin)
        - # 				return sin(args...)
        - # 			elseif(s == :cos)
        - # 				return cos(args...)
     4208 # 			end
        - # 		end
        - 
        - 
        - # function evaluate(s::Symbol, nvals)
        - # 	if(s == :+)
        - # 		return Base.sum(nvals)
        - # 	elseif(s == :-)
        - # 		return (-)(nvals[1],nvals[2])
        - # 	elseif(s == :*)
        - # 		return Base.prod(nvals)
        - # 	elseif(s == :/)
        - # 		return (/)(nvals[1],nvals[2])
        - # 	elseif(s == :^)
        - # 		return (^)(nvals[1],nvals[2])
        - # 	elseif(s == :sin)
        - # 		return sin(nvals[1])
        - # 	elseif(s == :cos)
        - # 		return cos(nvals[1])
        - # 	end
        - # end
        - 
        - 
        - function forward_evaluate(tt::TT_TYPE, vvals::TV_TYPE, pvals::TV_TYPE)
        - 	# vals = Array{VV_TYPE,1}()
    33520 	t_i = 0.0
        0 	t_p = 0.0
        0 	n_p = 0::Int
        0 	t_v = 0.0
        0 	n_v = 0::Int
        0 	t_o = 0.0
        0 	n_o = 0::Int
        - 	
       32 	tic()	
        0 	idx = 1::Int
       64 	vals = Array{Float64,1}()
       80 	v = Array{Float64,1}(1)
        - 
        0 	sizehint!(v,1)
  8000080 	sizehint!(vals,1000010)
       48 	t_i+=toq()
        0 	@show t_i
        - 
        0 	while(idx <= length(tt))
        - 		# @show idx
        0 		@inbounds ntype = tt[idx]
        0 		idx += 1
        0 		v[1] = 0.0
        0 		if(ntype == TYPE_P)
224000000 			tic()
        0 			@inbounds v[1] = pvals[tt[idx]]
        0 			idx += 1
        0 			@inbounds push!(vals,v[1])
        0 			idx += 1 #skip TYPE_P
336000000 			t_p += toq()
        0 			n_p += 1
        0 		elseif(ntype == TYPE_V)
128000000 			tic()
        0 			@inbounds v[1] = vvals[tt[idx]]
        0 			idx += 1
        0 			@inbounds push!(vals,v[1])
        0 			idx += 1 #skip TYPE_V
192000000 			t_v += toq()
        0 			n_v += 1
        0 		elseif(ntype == TYPE_O)
288000032 			tic()
        0 			@inbounds oc = tt[idx]
        0 			idx += 1
        0 			@inbounds n = tt[idx]
        0 			idx += 1
        0 			idx += 1 #skip TYPE_O
        - 			# s = OP[oc]
        - 		 	# v = evaluate(OP[oc],vals[length(vals)-n+1:1:length(vals)])::Float64
        0 		 	@inbounds evaluate(OP[oc],vals,length(vals)-n+1,v)
        0 			@inbounds resize!(vals,length(vals)-n+1)
        - 			# @show v
        0 			@inbounds vals[end] = v[1]
432000048 			t_o += toq()
        0 			n_o += 1
        - 		end
        - 	end
        - 	# @show vals
        0 	@show n_p, t_p
        0 	@show n_v, t_v
        0 	@show n_o, t_o
        0 	return vals[1]
        - end
        - 
        - 
        - 
        - function evaluate(s::Symbol, nvals::Array{VV_TYPE,1}, i, result::Array{VV_TYPE,1})
        - 	# n = length(nvals)
        0 	if(s == :+)
        0 		@inbounds result[1] = 0.0
        0 		@simd for j=i:1:length(nvals)
        0 			@inbounds result[1]+=nvals[j]
        - 		end
        0 	elseif(s == :-)
        0 		@inbounds return (-)(nvals[i],nvals[i+1])
        0 	elseif(s == :*)
        0 		@inbounds result[1] = nvals[i]
        0 		@simd for j=i+1:1:length(nvals)
        0 			@inbounds result[1] *= nvals[j]
        - 		end
        0 	elseif(s == :/)
        0 		@inbounds result[1]=(/)(nvals[i],nvals[i+1])
        0 	elseif(s == :^)
        0 		@inbounds result[1]=(^)(nvals[i],nvals[i+1])
        0 	elseif(s == :sin)
        0 		@inbounds result[1]=sin(nvals[i])
        0 	elseif(s == :cos)
        0 		@inbounds result[1]=cos(nvals[i])
        - 	end
        - end
        - 
        - 
        - ## Interface method
        - function feval(tt::TT_TYPE, vvals::TV_TYPE, pvals::TV_TYPE)
        - 	# (val::Float64,idx) = evaluate(tt,length(tt),vvals, pvals)
        - 	# nvals = Array{Float64,1}(1000000)
        - 	# nvals = Array{Float64,1}(1000000)
        0 	val = forward_evaluate(tt,vvals,pvals)
        0 	return val
        - end
        - 
julia> @time ReverseDiffTape.feval(tt,x,p)
t_i = 3.7692e-5
(n_p,t_p) = (7000000,4.107760328004933)
(n_v,t_v) = (4000000,2.359614993003405)
(n_o,t_o) = (9000001,6.057671650986469)
 21.679978 seconds (100.00 M allocations: 1.498 GB, 3.87% gc time)
294.79643051206546
