        - 
        - #forward evaluation for a scalar function
        - function forward_evaluate{I,V}(tape::Tape{I}, vvals::Array{V,1}, pvals::Array{V,1})
    85824 	tt = tape.tt
        0 	idx = one(I)
       64 	vals = Array{V,1}()
       80 	v = [zero(V)]
        - 
        0 	sizehint!(v,1)
  8000000 	sizehint!(vals,tape.maxoperands)
        - 	
        0 	@inbounds while(idx <= length(tt))
        - 		# @show idx
        0 		ntype = tt[idx]
        0 		idx += 1
        0 		v[1] = zero(V)
        0 		if(ntype == TYPE_P)
        0 			@inbounds v[1] = pvals[tt[idx]]
        0 			idx += 1
        0 			@inbounds push!(vals,v[1])
        0 			idx += 1 #skip TYPE_P
        0 		elseif(ntype == TYPE_V)
        0 			@inbounds v[1] = vvals[tt[idx]]
        0 			idx += 1
  8000000 			@inbounds push!(vals,v[1])
        0 			idx += 1 #skip TYPE_V
        0 		elseif(ntype == TYPE_O)
        0 			@inbounds oc = tt[idx]
        0 			idx += 1
        0 			@inbounds n = tt[idx]
        0 			idx += 1
        0 			idx += 1 #skip TYPE_O
        - 			# @show OP[oc],vals
        0 			@inbounds evaluate(OP[oc],vals,length(vals)-n+1,v)
        0 			@inbounds resize!(vals,length(vals)-n+1)
        - 			# @show v
        0 			@inbounds vals[end] = v[1]
        - 		end
        - 		# @show vals
        - 	end
        0 	return vals[1]
        - end
        - 
        - ## Interface method
        - function feval{I,V}(tape::Tape{I}, vvals::Array{V,1}, pvals::Array{V,1})
        0 	val = forward_evaluate(tape,vvals,pvals)
        0 	return val
        - end
        - 
